1. Создаем папки client | server
2. Создаем корневой файл index.js
3. Инициализируем проект | npm init -y
4. Устанавливаем необходимые инструменты: express (фрэймворк для создания Веб-приложений и API), pg, pg-hstore (управление БД), sequelize (ORM-библиотека для работы с БД), 
												   cors (осуществляет обращения из браузера к серверу), dotenv (для задавния переменных окружения)
												   npm install express pg pg-hstore sequelize cors dotenv
5.Установим NodeMone (служит для того, что при измении кода каждый раз не перезапускать server) | npm install -D nodemon
6.В index.js в скриптах прописываем команду,которая запускает проект в режиме разработки | "develop": "nodemon index.js"
7.Создаем файл где будут храниться переменные окружения .env -> указывааем порт на котором будет запущен сервер
8.В файл index.js импортируем конфигурацию .env, фреймворк express, командой npm run develop запускаем наш сервер
9.Создаем файл db.js, в нем будет описано подключение к БД
10.Создаем БД
11.В файле .env прописываем парметры подключения
12.В файл index.js импортируем объект класса, которые сделали в файле db.js
13.В файл index.js вызываем функцию для подлкючения к БД и старта проекта
14.Создаем схему БД
15.Переносим схему БД, создаем директорию model и файл model.js
16.В файл model.js импортируем объект класса, которые сделали в файле db.js, так же импортируем класс DataTypes при помощи которого описываются типы данных из пакета Sequelize
17.Описываем схему данных User,Basket... передаем название модели и атрибуты таблицы
18.Описываем связи между таблицами
19.Экспортируем объекты для дальнейшего использования в каких либо файлах
20.Импортируем объекты в файл index.js
21.Импортируем cors
22.Создаем папку Routes, в нее добавляем файлы index.js,userRouter...файл index.js юудет совмещать в себе эти роуты
23.В файле index.js создаем объект Router(импортируем роутер из express), экспортируем роутер из этого класса
24.Вызываем функцию use и первым параметром передем url по которому будет отрабатывать роутер,позже передадим туда сам роутер
25.Создаем методы GET,POST в дочерних файлах директории Routes
26.Импортируем все роутеры в файл index.js
27.Импортируем основной роутер в файл server/index.js
28.Вызываем функцию app.use первым парметром передаем url, а вторым сам роутер
29.Декомпозируем Router, чтобы не писать функцию вызова напрямую в роутере, создадим папку controllers, в которой создам контроллер для каждого роутера
30.В каждом дочернем файле директории Controllers создадим классы с соответствующими функциями
31.Импортируем созданный класс в соответсвующий файл директории Router
32.В соответствующий метод POST,GET вторым параметром передаем соотвествующую функцию
33.Создадим папку error, в ней файл ApiError.js, создаем класс ApiError, при помощи конструктора создадим то, что получаем параметрами
34.Создадим несколько статических фукнций c ошибками
35.Научимся добавлять объекты в БД, в файле typeController импортируем model и ApiError
36.Пишем асинхронные функции на добавление и получение типа
37.Пишем асинхронные функции на добавление и получение бренда
38.Доустановим модуль express-fileupload для работы с img
39.Доустановим пакет uuid(генератор случайных id)
40.Создадим папку static, в ней будут храниться все файлы, которые будут отправляться с клиента, после научим сервер отдавать файлы, как статику
41.Напишем запрос для создания Продукта
42.Добавим в запросе на получение всех продуктам 2 переменные(страница, лимит)
43.В файле модели БД, в описании связей Информации о товаре, параметром передадим поля которое будет у массива характеристик
44.Импортируем модель ProductInfo в ProductController
45.Добавим условие если инфо есть, то парсим объект в json, а после в JS объект
46.Пишем функцию получения одно продукта, вызываем функцию findOne и указываем условие по котоому этот продукт надо искать, так же нужно получить характеристики

С БРЭНДАМИ, ТИПАМИ, ПРОДУКТАМИ ЗАКОНЧИЛИ

АВТОРИЗАЦИЯ
47.Установим модули jsonwebtoken и bcrypt 
48.Реализуем функцию регистрации пользователя с хешированием пароля и созданием токена
49.Реализуем функцию логина пользователя
50.Реализуем еще один middleware, для аутентификации пользователя
51.Создадим еще один MiddleWare "authMiddleWare" , с котором будем декодировать токен и проверять его на валидность
52.Напишем функцию чек, которая будет сводится к тому, чтобы сгенерировать новый токен и отправить его обратно на клиент
53.Напишем еще один middleWare на проверку роли пользователя
!!!Добавить удаление товара!!!

Переходим к  КЛИЕНТСКОЙ части приложения
54.Перходим в папку client и с помощью утилиты npx create-react-app разворачиваем реакт приложение
55.Доустановим необходимые зависимости: axios(для отправки запросов на сервер), react-router-dom(для постраничной навигации),mobx(стейт менеджер)
и mobx-react-lite (для связи функциональных компонентов react с mobx)
56.Так же будем использовать react-bootstrap, чтобы эффективно и быстро сверстать сайт
57.Так же добавим стили, скопируем ссылку и добавим в корневой index.html
58.Создадим структуру приложения, нужные директори:store(в ней будем взаимодействовать с mobx и хранить какие нибудь данные,
pages(там буду корневые компоненты-страницы, components(хранятся компоненты)
59.Создадим ведущие страницы-Auth.js(авторизация),Shop.js(основная страница магазина),ProductPage(страница конкретного товара),Admin.js(админ панель),Basket.js(страница с корзиной)
60.Создадим в папке components файл Approute, чтобы задать навигациб по страницам
61.Создадим файл Routes.js, в котором будут описаны все маршруты
62.Компонент Routes работает таким образом, мы указываем несколько маршрутов и к примеру пользователь ошибся, то отработает самый последний маршрут
63.Пищем функцию маршрутов и отрисовки  элементов, доступных каждой роли
64.Создадим глобальное хранилище UserStore и ProductStore, создадим конструкторы, экшены и геттеры(в ProductStore,написаны заглушки, пока приложение не научится отправлять запросы на сервер)
65.Создадим в компонентах NavBar,добавим userContext
66.Из библиотеки bootstrap возьмем готовый navbar, изменим плашки на нужные нам, добавим проверку на авторизованность,обернув NavBar в блок observer,проверим работоспособность.
